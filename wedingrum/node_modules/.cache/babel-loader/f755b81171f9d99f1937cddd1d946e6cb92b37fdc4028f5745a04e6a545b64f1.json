{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { getMonthsInYear } from '../../utils/date-utils';\nexport const getDateSectionConfigFromFormatToken = (utils, formatToken) => {\n  const config = utils.formatTokenMap[formatToken];\n  if (config == null) {\n    throw new Error([\"MUI: The token \\\"\".concat(formatToken, \"\\\" is not supported by the Date and Time Pickers.\"), 'Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported.'].join('\\n'));\n  }\n  if (typeof config === 'string') {\n    return {\n      type: config,\n      contentType: config === 'meridiem' ? 'letter' : 'digit',\n      maxLength: undefined\n    };\n  }\n  return {\n    type: config.sectionType,\n    contentType: config.contentType,\n    maxLength: config.maxLength\n  };\n};\nconst getDeltaFromKeyCode = keyCode => {\n  switch (keyCode) {\n    case 'ArrowUp':\n      return 1;\n    case 'ArrowDown':\n      return -1;\n    case 'PageUp':\n      return 5;\n    case 'PageDown':\n      return -5;\n    default:\n      return 0;\n  }\n};\nexport const getDaysInWeekStr = (utils, timezone, format) => {\n  const elements = [];\n  const now = utils.dateWithTimezone(undefined, timezone);\n  const startDate = utils.startOfWeek(now);\n  const endDate = utils.endOfWeek(now);\n  let current = startDate;\n  while (utils.isBefore(current, endDate)) {\n    elements.push(current);\n    current = utils.addDays(current, 1);\n  }\n  return elements.map(weekDay => utils.formatByString(weekDay, format));\n};\nexport const getLetterEditingOptions = (utils, timezone, sectionType, format) => {\n  switch (sectionType) {\n    case 'month':\n      {\n        return getMonthsInYear(utils, utils.dateWithTimezone(undefined, timezone)).map(month => utils.formatByString(month, format));\n      }\n    case 'weekDay':\n      {\n        return getDaysInWeekStr(utils, timezone, format);\n      }\n    case 'meridiem':\n      {\n        const now = utils.dateWithTimezone(undefined, timezone);\n        return [utils.startOfDay(now), utils.endOfDay(now)].map(date => utils.formatByString(date, format));\n      }\n    default:\n      {\n        return [];\n      }\n  }\n};\nexport const cleanLeadingZeros = (utils, valueStr, size) => {\n  let cleanValueStr = valueStr;\n\n  // Remove the leading zeros\n  cleanValueStr = Number(cleanValueStr).toString();\n\n  // Add enough leading zeros to fill the section\n  while (cleanValueStr.length < size) {\n    cleanValueStr = \"0\".concat(cleanValueStr);\n  }\n  return cleanValueStr;\n};\nexport const cleanDigitSectionValue = (utils, timezone, value, sectionBoundaries, section) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (section.type !== 'day' && section.contentType === 'digit-with-letter') {\n      throw new Error([\"MUI: The token \\\"\".concat(section.format, \"\\\" is a digit format with letter in it.'\\n             This type of format is only supported for 'day' sections\")].join('\\n'));\n    }\n  }\n  if (section.type === 'day' && section.contentType === 'digit-with-letter') {\n    const date = utils.setDate(sectionBoundaries.longestMonth, value);\n    return utils.formatByString(date, section.format);\n  }\n\n  // queryValue without leading `0` (`01` => `1`)\n  const valueStr = value.toString();\n  if (section.hasLeadingZerosInInput) {\n    return cleanLeadingZeros(utils, valueStr, section.maxLength);\n  }\n  return valueStr;\n};\nexport const adjustSectionValue = (utils, timezone, section, keyCode, sectionsValueBoundaries, activeDate, stepsAttributes) => {\n  const delta = getDeltaFromKeyCode(keyCode);\n  const isStart = keyCode === 'Home';\n  const isEnd = keyCode === 'End';\n  const shouldSetAbsolute = section.value === '' || isStart || isEnd;\n  const adjustDigitSection = () => {\n    const sectionBoundaries = sectionsValueBoundaries[section.type]({\n      currentDate: activeDate,\n      format: section.format,\n      contentType: section.contentType\n    });\n    const getCleanValue = value => cleanDigitSectionValue(utils, timezone, value, sectionBoundaries, section);\n    const step = section.type === 'minutes' && stepsAttributes != null && stepsAttributes.minutesStep ? stepsAttributes.minutesStep : 1;\n    const currentSectionValue = parseInt(section.value, 10);\n    let newSectionValueNumber = currentSectionValue + delta * step;\n    if (shouldSetAbsolute) {\n      if (section.type === 'year' && !isEnd && !isStart) {\n        return utils.formatByString(utils.dateWithTimezone(undefined, timezone), section.format);\n      }\n      if (delta > 0 || isStart) {\n        newSectionValueNumber = sectionBoundaries.minimum;\n      } else {\n        newSectionValueNumber = sectionBoundaries.maximum;\n      }\n    }\n    if (newSectionValueNumber % step !== 0) {\n      if (delta < 0 || isStart) {\n        newSectionValueNumber += step - (step + newSectionValueNumber) % step; // for JS -3 % 5 = -3 (should be 2)\n      }\n\n      if (delta > 0 || isEnd) {\n        newSectionValueNumber -= newSectionValueNumber % step;\n      }\n    }\n    if (newSectionValueNumber > sectionBoundaries.maximum) {\n      return getCleanValue(sectionBoundaries.minimum + (newSectionValueNumber - sectionBoundaries.maximum - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));\n    }\n    if (newSectionValueNumber < sectionBoundaries.minimum) {\n      return getCleanValue(sectionBoundaries.maximum - (sectionBoundaries.minimum - newSectionValueNumber - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));\n    }\n    return getCleanValue(newSectionValueNumber);\n  };\n  const adjustLetterSection = () => {\n    const options = getLetterEditingOptions(utils, timezone, section.type, section.format);\n    if (options.length === 0) {\n      return section.value;\n    }\n    if (shouldSetAbsolute) {\n      if (delta > 0 || isStart) {\n        return options[0];\n      }\n      return options[options.length - 1];\n    }\n    const currentOptionIndex = options.indexOf(section.value);\n    const newOptionIndex = (currentOptionIndex + options.length + delta) % options.length;\n    return options[newOptionIndex];\n  };\n  if (section.contentType === 'digit' || section.contentType === 'digit-with-letter') {\n    return adjustDigitSection();\n  }\n  return adjustLetterSection();\n};\nexport const getSectionVisibleValue = (section, target) => {\n  let value = section.value || section.placeholder;\n  const hasLeadingZeros = target === 'non-input' ? section.hasLeadingZerosInFormat : section.hasLeadingZerosInInput;\n  if (target === 'non-input' && section.hasLeadingZerosInInput && !section.hasLeadingZerosInFormat) {\n    value = Number(value).toString();\n  }\n\n  // In the input, we add an empty character at the end of each section without leading zeros.\n  // This makes sure that `onChange` will always be fired.\n  // Otherwise, when your input value equals `1/dd/yyyy` (format `M/DD/YYYY` on DayJs),\n  // If you press `1`, on the first section, the new value is also `1/dd/yyyy`,\n  // So the browser will not fire the input `onChange`.\n  const shouldAddInvisibleSpace = ['input-rtl', 'input-ltr'].includes(target) && section.contentType === 'digit' && !hasLeadingZeros && value.length === 1;\n  if (shouldAddInvisibleSpace) {\n    value = \"\".concat(value, \"\\u200E\");\n  }\n  if (target === 'input-rtl') {\n    value = \"\\u2068\".concat(value, \"\\u2069\");\n  }\n  return value;\n};\nexport const cleanString = dirtyString => dirtyString.replace(/[\\u2066\\u2067\\u2068\\u2069]/g, '');\nexport const addPositionPropertiesToSections = (sections, isRTL) => {\n  let position = 0;\n  let positionInInput = isRTL ? 1 : 0;\n  const newSections = [];\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const renderedValue = getSectionVisibleValue(section, isRTL ? 'input-rtl' : 'input-ltr');\n    const sectionStr = \"\".concat(section.startSeparator).concat(renderedValue).concat(section.endSeparator);\n    const sectionLength = cleanString(sectionStr).length;\n    const sectionLengthInInput = sectionStr.length;\n\n    // The ...InInput values consider the unicode characters but do include them in their indexes\n    const cleanedValue = cleanString(renderedValue);\n    const startInInput = positionInInput + renderedValue.indexOf(cleanedValue[0]) + section.startSeparator.length;\n    const endInInput = startInInput + cleanedValue.length;\n    newSections.push(_extends({}, section, {\n      start: position,\n      end: position + sectionLength,\n      startInInput,\n      endInInput\n    }));\n    position += sectionLength;\n    // Move position to the end of string associated to the current section\n    positionInInput += sectionLengthInInput;\n  }\n  return newSections;\n};\nconst getSectionPlaceholder = (utils, timezone, localeText, sectionConfig, currentTokenValue) => {\n  switch (sectionConfig.type) {\n    case 'year':\n      {\n        return localeText.fieldYearPlaceholder({\n          digitAmount: utils.formatByString(utils.dateWithTimezone(undefined, timezone), currentTokenValue).length\n        });\n      }\n    case 'month':\n      {\n        return localeText.fieldMonthPlaceholder({\n          contentType: sectionConfig.contentType\n        });\n      }\n    case 'day':\n      {\n        return localeText.fieldDayPlaceholder();\n      }\n    case 'weekDay':\n      {\n        return localeText.fieldWeekDayPlaceholder({\n          contentType: sectionConfig.contentType\n        });\n      }\n    case 'hours':\n      {\n        return localeText.fieldHoursPlaceholder();\n      }\n    case 'minutes':\n      {\n        return localeText.fieldMinutesPlaceholder();\n      }\n    case 'seconds':\n      {\n        return localeText.fieldSecondsPlaceholder();\n      }\n    case 'meridiem':\n      {\n        return localeText.fieldMeridiemPlaceholder();\n      }\n    default:\n      {\n        return currentTokenValue;\n      }\n  }\n};\nexport const changeSectionValueFormat = (utils, valueStr, currentFormat, newFormat) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (getDateSectionConfigFromFormatToken(utils, currentFormat).type === 'weekDay') {\n      throw new Error(\"changeSectionValueFormat doesn't support week day formats\");\n    }\n  }\n  return utils.formatByString(utils.parse(valueStr, currentFormat), newFormat);\n};\nconst isFourDigitYearFormat = (utils, timezone, format) => utils.formatByString(utils.dateWithTimezone(undefined, timezone), format).length === 4;\nexport const doesSectionFormatHaveLeadingZeros = (utils, timezone, contentType, sectionType, format) => {\n  if (contentType !== 'digit') {\n    return false;\n  }\n  const now = utils.dateWithTimezone(undefined, timezone);\n  switch (sectionType) {\n    // We can't use `changeSectionValueFormat`, because  `utils.parse('1', 'YYYY')` returns `1971` instead of `1`.\n    case 'year':\n      {\n        if (isFourDigitYearFormat(utils, timezone, format)) {\n          const formatted0001 = utils.formatByString(utils.setYear(now, 1), format);\n          return formatted0001 === '0001';\n        }\n        const formatted2001 = utils.formatByString(utils.setYear(now, 2001), format);\n        return formatted2001 === '01';\n      }\n    case 'month':\n      {\n        return utils.formatByString(utils.startOfYear(now), format).length > 1;\n      }\n    case 'day':\n      {\n        return utils.formatByString(utils.startOfMonth(now), format).length > 1;\n      }\n    case 'weekDay':\n      {\n        return utils.formatByString(utils.startOfWeek(now), format).length > 1;\n      }\n    case 'hours':\n      {\n        return utils.formatByString(utils.setHours(now, 1), format).length > 1;\n      }\n    case 'minutes':\n      {\n        return utils.formatByString(utils.setMinutes(now, 1), format).length > 1;\n      }\n    case 'seconds':\n      {\n        return utils.formatByString(utils.setSeconds(now, 1), format).length > 1;\n      }\n    default:\n      {\n        throw new Error('Invalid section type');\n      }\n  }\n};\nconst getEscapedPartsFromFormat = (utils, format) => {\n  const escapedParts = [];\n  const {\n    start: startChar,\n    end: endChar\n  } = utils.escapedCharacters;\n  const regExp = new RegExp(\"(\\\\\".concat(startChar, \"[^\\\\\").concat(endChar, \"]*\\\\\").concat(endChar, \")+\"), 'g');\n  let match = null;\n  // eslint-disable-next-line no-cond-assign\n  while (match = regExp.exec(format)) {\n    escapedParts.push({\n      start: match.index,\n      end: regExp.lastIndex - 1\n    });\n  }\n  return escapedParts;\n};\nexport const splitFormatIntoSections = (utils, timezone, localeText, format, date, formatDensity, shouldRespectLeadingZeros, isRTL) => {\n  let startSeparator = '';\n  const sections = [];\n  const now = utils.date();\n  const commitToken = token => {\n    if (token === '') {\n      return null;\n    }\n    const sectionConfig = getDateSectionConfigFromFormatToken(utils, token);\n    const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils, timezone, sectionConfig.contentType, sectionConfig.type, token);\n    const hasLeadingZerosInInput = shouldRespectLeadingZeros ? hasLeadingZerosInFormat : sectionConfig.contentType === 'digit';\n    const isValidDate = date != null && utils.isValid(date);\n    let sectionValue = isValidDate ? utils.formatByString(date, token) : '';\n    let maxLength = null;\n    if (hasLeadingZerosInInput) {\n      if (hasLeadingZerosInFormat) {\n        maxLength = sectionValue === '' ? utils.formatByString(now, token).length : sectionValue.length;\n      } else {\n        if (sectionConfig.maxLength == null) {\n          throw new Error(\"MUI: The token \".concat(token, \" should have a 'maxDigitNumber' property on it's adapter\"));\n        }\n        maxLength = sectionConfig.maxLength;\n        if (isValidDate) {\n          sectionValue = cleanLeadingZeros(utils, sectionValue, maxLength);\n        }\n      }\n    }\n    sections.push(_extends({}, sectionConfig, {\n      format: token,\n      maxLength,\n      value: sectionValue,\n      placeholder: getSectionPlaceholder(utils, timezone, localeText, sectionConfig, token),\n      hasLeadingZeros: hasLeadingZerosInFormat,\n      hasLeadingZerosInFormat,\n      hasLeadingZerosInInput,\n      startSeparator: sections.length === 0 ? startSeparator : '',\n      endSeparator: '',\n      modified: false\n    }));\n    return null;\n  };\n\n  // Expand the provided format\n  let formatExpansionOverflow = 10;\n  let prevFormat = format;\n  let nextFormat = utils.expandFormat(format);\n  while (nextFormat !== prevFormat) {\n    prevFormat = nextFormat;\n    nextFormat = utils.expandFormat(prevFormat);\n    formatExpansionOverflow -= 1;\n    if (formatExpansionOverflow < 0) {\n      throw new Error('MUI: The format expansion seems to be  enter in an infinite loop. Please open an issue with the format passed to the picker component');\n    }\n  }\n  const expandedFormat = nextFormat;\n\n  // Get start/end indexes of escaped sections\n  const escapedParts = getEscapedPartsFromFormat(utils, expandedFormat);\n\n  // This RegExp test if the beginning of a string correspond to a supported token\n  const isTokenStartRegExp = new RegExp(\"^(\".concat(Object.keys(utils.formatTokenMap).sort((a, b) => b.length - a.length) // Sort to put longest word first\n  .join('|'), \")\"), 'g') // used to get access to lastIndex state\n  ;\n\n  let currentTokenValue = '';\n  for (let i = 0; i < expandedFormat.length; i += 1) {\n    const escapedPartOfCurrentChar = escapedParts.find(escapeIndex => escapeIndex.start <= i && escapeIndex.end >= i);\n    const char = expandedFormat[i];\n    const isEscapedChar = escapedPartOfCurrentChar != null;\n    const potentialToken = \"\".concat(currentTokenValue).concat(expandedFormat.slice(i));\n    const regExpMatch = isTokenStartRegExp.test(potentialToken);\n    if (!isEscapedChar && char.match(/([A-Za-z]+)/) && regExpMatch) {\n      currentTokenValue = potentialToken.slice(0, isTokenStartRegExp.lastIndex);\n      i += isTokenStartRegExp.lastIndex - 1;\n    } else {\n      // If we are on the opening or closing character of an escaped part of the format,\n      // Then we ignore this character.\n      const isEscapeBoundary = isEscapedChar && (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.start) === i || (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.end) === i;\n      if (!isEscapeBoundary) {\n        commitToken(currentTokenValue);\n        currentTokenValue = '';\n        if (sections.length === 0) {\n          startSeparator += char;\n        } else {\n          sections[sections.length - 1].endSeparator += char;\n        }\n      }\n    }\n  }\n  commitToken(currentTokenValue);\n  return sections.map(section => {\n    const cleanSeparator = separator => {\n      let cleanedSeparator = separator;\n      if (isRTL && cleanedSeparator !== null && cleanedSeparator.includes(' ')) {\n        cleanedSeparator = \"\\u2069\".concat(cleanedSeparator, \"\\u2066\");\n      }\n      if (formatDensity === 'spacious' && ['/', '.', '-'].includes(cleanedSeparator)) {\n        cleanedSeparator = \" \".concat(cleanedSeparator, \" \");\n      }\n      return cleanedSeparator;\n    };\n    section.startSeparator = cleanSeparator(section.startSeparator);\n    section.endSeparator = cleanSeparator(section.endSeparator);\n    return section;\n  });\n};\n\n/**\r\n * Some date libraries like `dayjs` don't support parsing from date with escaped characters.\r\n * To make sure that the parsing works, we are building a format and a date without any separator.\r\n */\nexport const getDateFromDateSections = (utils, sections) => {\n  // If we have both a day and a weekDay section,\n  // Then we skip the weekDay in the parsing because libraries like dayjs can't parse complicated formats containing a weekDay.\n  // dayjs(dayjs().format('dddd MMMM D YYYY'), 'dddd MMMM D YYYY')) // returns `Invalid Date` even if the format is valid.\n  const shouldSkipWeekDays = sections.some(section => section.type === 'day');\n  const sectionFormats = [];\n  const sectionValues = [];\n  for (let i = 0; i < sections.length; i += 1) {\n    const section = sections[i];\n    const shouldSkip = shouldSkipWeekDays && section.type === 'weekDay';\n    if (!shouldSkip) {\n      sectionFormats.push(section.format);\n      sectionValues.push(getSectionVisibleValue(section, 'non-input'));\n    }\n  }\n  const formatWithoutSeparator = sectionFormats.join(' ');\n  const dateWithoutSeparatorStr = sectionValues.join(' ');\n  return utils.parse(dateWithoutSeparatorStr, formatWithoutSeparator);\n};\nexport const createDateStrForInputFromSections = (sections, isRTL) => {\n  const formattedSections = sections.map(section => {\n    const dateValue = getSectionVisibleValue(section, isRTL ? 'input-rtl' : 'input-ltr');\n    return \"\".concat(section.startSeparator).concat(dateValue).concat(section.endSeparator);\n  });\n  const dateStr = formattedSections.join('');\n  if (!isRTL) {\n    return dateStr;\n  }\n\n  // \\u2066: start left-to-right isolation\n  // \\u2067: start right-to-left isolation\n  // \\u2068: start first strong character isolation\n  // \\u2069: pop isolation\n  // wrap into an isolated group such that separators can split the string in smaller ones by adding \\u2069\\u2068\n  return \"\\u2066\".concat(dateStr, \"\\u2069\");\n};\nexport const getSectionsBoundaries = (utils, timezone) => {\n  const today = utils.dateWithTimezone(undefined, timezone);\n  const endOfYear = utils.endOfYear(today);\n  const endOfDay = utils.endOfDay(today);\n  const {\n    maxDaysInMonth,\n    longestMonth\n  } = getMonthsInYear(utils, today).reduce((acc, month) => {\n    const daysInMonth = utils.getDaysInMonth(month);\n    if (daysInMonth > acc.maxDaysInMonth) {\n      return {\n        maxDaysInMonth: daysInMonth,\n        longestMonth: month\n      };\n    }\n    return acc;\n  }, {\n    maxDaysInMonth: 0,\n    longestMonth: null\n  });\n  return {\n    year: _ref => {\n      let {\n        format\n      } = _ref;\n      return {\n        minimum: 0,\n        maximum: isFourDigitYearFormat(utils, timezone, format) ? 9999 : 99\n      };\n    },\n    month: () => ({\n      minimum: 1,\n      // Assumption: All years have the same amount of months\n      maximum: utils.getMonth(endOfYear) + 1\n    }),\n    day: _ref2 => {\n      let {\n        currentDate\n      } = _ref2;\n      return {\n        minimum: 1,\n        maximum: currentDate != null && utils.isValid(currentDate) ? utils.getDaysInMonth(currentDate) : maxDaysInMonth,\n        longestMonth: longestMonth\n      };\n    },\n    weekDay: _ref3 => {\n      let {\n        format,\n        contentType\n      } = _ref3;\n      if (contentType === 'digit') {\n        const daysInWeek = getDaysInWeekStr(utils, timezone, format).map(Number);\n        return {\n          minimum: Math.min(...daysInWeek),\n          maximum: Math.max(...daysInWeek)\n        };\n      }\n      return {\n        minimum: 1,\n        maximum: 7\n      };\n    },\n    hours: _ref4 => {\n      let {\n        format\n      } = _ref4;\n      const lastHourInDay = utils.getHours(endOfDay);\n      const hasMeridiem = utils.formatByString(utils.endOfDay(today), format) !== lastHourInDay.toString();\n      if (hasMeridiem) {\n        return {\n          minimum: 1,\n          maximum: Number(utils.formatByString(utils.startOfDay(today), format))\n        };\n      }\n      return {\n        minimum: 0,\n        maximum: lastHourInDay\n      };\n    },\n    minutes: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of minutes\n      maximum: utils.getMinutes(endOfDay)\n    }),\n    seconds: () => ({\n      minimum: 0,\n      // Assumption: All years have the same amount of seconds\n      maximum: utils.getSeconds(endOfDay)\n    }),\n    meridiem: () => ({\n      minimum: 0,\n      maximum: 0\n    })\n  };\n};\nlet warnedOnceInvalidSection = false;\nexport const validateSections = (sections, valueType) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!warnedOnceInvalidSection) {\n      const supportedSections = [];\n      if (['date', 'date-time'].includes(valueType)) {\n        supportedSections.push('weekDay', 'day', 'month', 'year');\n      }\n      if (['time', 'date-time'].includes(valueType)) {\n        supportedSections.push('hours', 'minutes', 'seconds', 'meridiem');\n      }\n      const invalidSection = sections.find(section => !supportedSections.includes(section.type));\n      if (invalidSection) {\n        console.warn(\"MUI: The field component you are using is not compatible with the \\\"\".concat(invalidSection.type, \" date section.\"), \"The supported date sections are [\\\"\".concat(supportedSections.join('\", \"'), \"\\\"]`.\"));\n        warnedOnceInvalidSection = true;\n      }\n    }\n  }\n};\nconst transferDateSectionValue = (utils, timezone, section, dateToTransferFrom, dateToTransferTo) => {\n  switch (section.type) {\n    case 'year':\n      {\n        return utils.setYear(dateToTransferTo, utils.getYear(dateToTransferFrom));\n      }\n    case 'month':\n      {\n        return utils.setMonth(dateToTransferTo, utils.getMonth(dateToTransferFrom));\n      }\n    case 'weekDay':\n      {\n        const formattedDaysInWeek = getDaysInWeekStr(utils, timezone, section.format);\n        const dayInWeekStrOfActiveDate = utils.formatByString(dateToTransferFrom, section.format);\n        const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);\n        const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);\n        const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;\n        return utils.addDays(dateToTransferFrom, diff);\n      }\n    case 'day':\n      {\n        return utils.setDate(dateToTransferTo, utils.getDate(dateToTransferFrom));\n      }\n    case 'meridiem':\n      {\n        const isAM = utils.getHours(dateToTransferFrom) < 12;\n        const mergedDateHours = utils.getHours(dateToTransferTo);\n        if (isAM && mergedDateHours >= 12) {\n          return utils.addHours(dateToTransferTo, -12);\n        }\n        if (!isAM && mergedDateHours < 12) {\n          return utils.addHours(dateToTransferTo, 12);\n        }\n        return dateToTransferTo;\n      }\n    case 'hours':\n      {\n        return utils.setHours(dateToTransferTo, utils.getHours(dateToTransferFrom));\n      }\n    case 'minutes':\n      {\n        return utils.setMinutes(dateToTransferTo, utils.getMinutes(dateToTransferFrom));\n      }\n    case 'seconds':\n      {\n        return utils.setSeconds(dateToTransferTo, utils.getSeconds(dateToTransferFrom));\n      }\n    default:\n      {\n        return dateToTransferTo;\n      }\n  }\n};\nconst reliableSectionModificationOrder = {\n  year: 1,\n  month: 2,\n  day: 3,\n  weekDay: 4,\n  hours: 5,\n  minutes: 6,\n  seconds: 7,\n  meridiem: 8\n};\nexport const mergeDateIntoReferenceDate = (utils, timezone, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) =>\n// cloning sections before sort to avoid mutating it\n[...sections].sort((a, b) => reliableSectionModificationOrder[a.type] - reliableSectionModificationOrder[b.type]).reduce((mergedDate, section) => {\n  if (!shouldLimitToEditedSections || section.modified) {\n    return transferDateSectionValue(utils, timezone, section, dateToTransferFrom, mergedDate);\n  }\n  return mergedDate;\n}, referenceDate);\nexport const isAndroid = () => navigator.userAgent.toLowerCase().indexOf('android') > -1;\nexport const getSectionOrder = (sections, isRTL) => {\n  const neighbors = {};\n  if (!isRTL) {\n    sections.forEach((_, index) => {\n      const leftIndex = index === 0 ? null : index - 1;\n      const rightIndex = index === sections.length - 1 ? null : index + 1;\n      neighbors[index] = {\n        leftIndex,\n        rightIndex\n      };\n    });\n    return {\n      neighbors,\n      startIndex: 0,\n      endIndex: sections.length - 1\n    };\n  }\n  const rtl2ltr = {};\n  const ltr2rtl = {};\n  let groupedSectionsStart = 0;\n  let groupedSectionsEnd = 0;\n  let RTLIndex = sections.length - 1;\n  while (RTLIndex >= 0) {\n    groupedSectionsEnd = sections.findIndex(\n    // eslint-disable-next-line @typescript-eslint/no-loop-func\n    (section, index) => {\n      var _section$endSeparator;\n      return index >= groupedSectionsStart && ((_section$endSeparator = section.endSeparator) == null ? void 0 : _section$endSeparator.includes(' ')) &&\n      // Special case where the spaces were not there in the initial input\n      section.endSeparator !== ' / ';\n    });\n    if (groupedSectionsEnd === -1) {\n      groupedSectionsEnd = sections.length - 1;\n    }\n    for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {\n      ltr2rtl[i] = RTLIndex;\n      rtl2ltr[RTLIndex] = i;\n      RTLIndex -= 1;\n    }\n    groupedSectionsStart = groupedSectionsEnd + 1;\n  }\n  sections.forEach((_, index) => {\n    const rtlIndex = ltr2rtl[index];\n    const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];\n    const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];\n    neighbors[index] = {\n      leftIndex,\n      rightIndex\n    };\n  });\n  return {\n    neighbors,\n    startIndex: rtl2ltr[0],\n    endIndex: rtl2ltr[sections.length - 1]\n  };\n};","map":{"version":3,"names":["_extends","getMonthsInYear","getDateSectionConfigFromFormatToken","utils","formatToken","config","formatTokenMap","Error","concat","join","type","contentType","maxLength","undefined","sectionType","getDeltaFromKeyCode","keyCode","getDaysInWeekStr","timezone","format","elements","now","dateWithTimezone","startDate","startOfWeek","endDate","endOfWeek","current","isBefore","push","addDays","map","weekDay","formatByString","getLetterEditingOptions","month","startOfDay","endOfDay","date","cleanLeadingZeros","valueStr","size","cleanValueStr","Number","toString","length","cleanDigitSectionValue","value","sectionBoundaries","section","process","env","NODE_ENV","setDate","longestMonth","hasLeadingZerosInInput","adjustSectionValue","sectionsValueBoundaries","activeDate","stepsAttributes","delta","isStart","isEnd","shouldSetAbsolute","adjustDigitSection","currentDate","getCleanValue","step","minutesStep","currentSectionValue","parseInt","newSectionValueNumber","minimum","maximum","adjustLetterSection","options","currentOptionIndex","indexOf","newOptionIndex","getSectionVisibleValue","target","placeholder","hasLeadingZeros","hasLeadingZerosInFormat","shouldAddInvisibleSpace","includes","cleanString","dirtyString","replace","addPositionPropertiesToSections","sections","isRTL","position","positionInInput","newSections","i","renderedValue","sectionStr","startSeparator","endSeparator","sectionLength","sectionLengthInInput","cleanedValue","startInInput","endInInput","start","end","getSectionPlaceholder","localeText","sectionConfig","currentTokenValue","fieldYearPlaceholder","digitAmount","fieldMonthPlaceholder","fieldDayPlaceholder","fieldWeekDayPlaceholder","fieldHoursPlaceholder","fieldMinutesPlaceholder","fieldSecondsPlaceholder","fieldMeridiemPlaceholder","changeSectionValueFormat","currentFormat","newFormat","parse","isFourDigitYearFormat","doesSectionFormatHaveLeadingZeros","formatted0001","setYear","formatted2001","startOfYear","startOfMonth","setHours","setMinutes","setSeconds","getEscapedPartsFromFormat","escapedParts","startChar","endChar","escapedCharacters","regExp","RegExp","match","exec","index","lastIndex","splitFormatIntoSections","formatDensity","shouldRespectLeadingZeros","commitToken","token","isValidDate","isValid","sectionValue","modified","formatExpansionOverflow","prevFormat","nextFormat","expandFormat","expandedFormat","isTokenStartRegExp","Object","keys","sort","a","b","escapedPartOfCurrentChar","find","escapeIndex","char","isEscapedChar","potentialToken","slice","regExpMatch","test","isEscapeBoundary","cleanSeparator","separator","cleanedSeparator","getDateFromDateSections","shouldSkipWeekDays","some","sectionFormats","sectionValues","shouldSkip","formatWithoutSeparator","dateWithoutSeparatorStr","createDateStrForInputFromSections","formattedSections","dateValue","dateStr","getSectionsBoundaries","today","endOfYear","maxDaysInMonth","reduce","acc","daysInMonth","getDaysInMonth","year","_ref","getMonth","day","_ref2","_ref3","daysInWeek","Math","min","max","hours","_ref4","lastHourInDay","getHours","hasMeridiem","minutes","getMinutes","seconds","getSeconds","meridiem","warnedOnceInvalidSection","validateSections","valueType","supportedSections","invalidSection","console","warn","transferDateSectionValue","dateToTransferFrom","dateToTransferTo","getYear","setMonth","formattedDaysInWeek","dayInWeekStrOfActiveDate","dayInWeekOfActiveDate","dayInWeekOfNewSectionValue","diff","getDate","isAM","mergedDateHours","addHours","reliableSectionModificationOrder","mergeDateIntoReferenceDate","referenceDate","shouldLimitToEditedSections","mergedDate","isAndroid","navigator","userAgent","toLowerCase","getSectionOrder","neighbors","forEach","_","leftIndex","rightIndex","startIndex","endIndex","rtl2ltr","ltr2rtl","groupedSectionsStart","groupedSectionsEnd","RTLIndex","findIndex","_section$endSeparator","rtlIndex"],"sources":["C:/Users/user/Desktop/WeddingRum-ec2/wedingrum/node_modules/@mui/x-date-pickers/internals/hooks/useField/useField.utils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\r\nimport { getMonthsInYear } from '../../utils/date-utils';\r\nexport const getDateSectionConfigFromFormatToken = (utils, formatToken) => {\r\n  const config = utils.formatTokenMap[formatToken];\r\n  if (config == null) {\r\n    throw new Error([`MUI: The token \"${formatToken}\" is not supported by the Date and Time Pickers.`, 'Please try using another token or open an issue on https://github.com/mui/mui-x/issues/new/choose if you think it should be supported.'].join('\\n'));\r\n  }\r\n  if (typeof config === 'string') {\r\n    return {\r\n      type: config,\r\n      contentType: config === 'meridiem' ? 'letter' : 'digit',\r\n      maxLength: undefined\r\n    };\r\n  }\r\n  return {\r\n    type: config.sectionType,\r\n    contentType: config.contentType,\r\n    maxLength: config.maxLength\r\n  };\r\n};\r\nconst getDeltaFromKeyCode = keyCode => {\r\n  switch (keyCode) {\r\n    case 'ArrowUp':\r\n      return 1;\r\n    case 'ArrowDown':\r\n      return -1;\r\n    case 'PageUp':\r\n      return 5;\r\n    case 'PageDown':\r\n      return -5;\r\n    default:\r\n      return 0;\r\n  }\r\n};\r\nexport const getDaysInWeekStr = (utils, timezone, format) => {\r\n  const elements = [];\r\n  const now = utils.dateWithTimezone(undefined, timezone);\r\n  const startDate = utils.startOfWeek(now);\r\n  const endDate = utils.endOfWeek(now);\r\n  let current = startDate;\r\n  while (utils.isBefore(current, endDate)) {\r\n    elements.push(current);\r\n    current = utils.addDays(current, 1);\r\n  }\r\n  return elements.map(weekDay => utils.formatByString(weekDay, format));\r\n};\r\nexport const getLetterEditingOptions = (utils, timezone, sectionType, format) => {\r\n  switch (sectionType) {\r\n    case 'month':\r\n      {\r\n        return getMonthsInYear(utils, utils.dateWithTimezone(undefined, timezone)).map(month => utils.formatByString(month, format));\r\n      }\r\n    case 'weekDay':\r\n      {\r\n        return getDaysInWeekStr(utils, timezone, format);\r\n      }\r\n    case 'meridiem':\r\n      {\r\n        const now = utils.dateWithTimezone(undefined, timezone);\r\n        return [utils.startOfDay(now), utils.endOfDay(now)].map(date => utils.formatByString(date, format));\r\n      }\r\n    default:\r\n      {\r\n        return [];\r\n      }\r\n  }\r\n};\r\nexport const cleanLeadingZeros = (utils, valueStr, size) => {\r\n  let cleanValueStr = valueStr;\r\n\r\n  // Remove the leading zeros\r\n  cleanValueStr = Number(cleanValueStr).toString();\r\n\r\n  // Add enough leading zeros to fill the section\r\n  while (cleanValueStr.length < size) {\r\n    cleanValueStr = `0${cleanValueStr}`;\r\n  }\r\n  return cleanValueStr;\r\n};\r\nexport const cleanDigitSectionValue = (utils, timezone, value, sectionBoundaries, section) => {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (section.type !== 'day' && section.contentType === 'digit-with-letter') {\r\n      throw new Error([`MUI: The token \"${section.format}\" is a digit format with letter in it.'\r\n             This type of format is only supported for 'day' sections`].join('\\n'));\r\n    }\r\n  }\r\n  if (section.type === 'day' && section.contentType === 'digit-with-letter') {\r\n    const date = utils.setDate(sectionBoundaries.longestMonth, value);\r\n    return utils.formatByString(date, section.format);\r\n  }\r\n\r\n  // queryValue without leading `0` (`01` => `1`)\r\n  const valueStr = value.toString();\r\n  if (section.hasLeadingZerosInInput) {\r\n    return cleanLeadingZeros(utils, valueStr, section.maxLength);\r\n  }\r\n  return valueStr;\r\n};\r\nexport const adjustSectionValue = (utils, timezone, section, keyCode, sectionsValueBoundaries, activeDate, stepsAttributes) => {\r\n  const delta = getDeltaFromKeyCode(keyCode);\r\n  const isStart = keyCode === 'Home';\r\n  const isEnd = keyCode === 'End';\r\n  const shouldSetAbsolute = section.value === '' || isStart || isEnd;\r\n  const adjustDigitSection = () => {\r\n    const sectionBoundaries = sectionsValueBoundaries[section.type]({\r\n      currentDate: activeDate,\r\n      format: section.format,\r\n      contentType: section.contentType\r\n    });\r\n    const getCleanValue = value => cleanDigitSectionValue(utils, timezone, value, sectionBoundaries, section);\r\n    const step = section.type === 'minutes' && stepsAttributes != null && stepsAttributes.minutesStep ? stepsAttributes.minutesStep : 1;\r\n    const currentSectionValue = parseInt(section.value, 10);\r\n    let newSectionValueNumber = currentSectionValue + delta * step;\r\n    if (shouldSetAbsolute) {\r\n      if (section.type === 'year' && !isEnd && !isStart) {\r\n        return utils.formatByString(utils.dateWithTimezone(undefined, timezone), section.format);\r\n      }\r\n      if (delta > 0 || isStart) {\r\n        newSectionValueNumber = sectionBoundaries.minimum;\r\n      } else {\r\n        newSectionValueNumber = sectionBoundaries.maximum;\r\n      }\r\n    }\r\n    if (newSectionValueNumber % step !== 0) {\r\n      if (delta < 0 || isStart) {\r\n        newSectionValueNumber += step - (step + newSectionValueNumber) % step; // for JS -3 % 5 = -3 (should be 2)\r\n      }\r\n\r\n      if (delta > 0 || isEnd) {\r\n        newSectionValueNumber -= newSectionValueNumber % step;\r\n      }\r\n    }\r\n    if (newSectionValueNumber > sectionBoundaries.maximum) {\r\n      return getCleanValue(sectionBoundaries.minimum + (newSectionValueNumber - sectionBoundaries.maximum - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));\r\n    }\r\n    if (newSectionValueNumber < sectionBoundaries.minimum) {\r\n      return getCleanValue(sectionBoundaries.maximum - (sectionBoundaries.minimum - newSectionValueNumber - 1) % (sectionBoundaries.maximum - sectionBoundaries.minimum + 1));\r\n    }\r\n    return getCleanValue(newSectionValueNumber);\r\n  };\r\n  const adjustLetterSection = () => {\r\n    const options = getLetterEditingOptions(utils, timezone, section.type, section.format);\r\n    if (options.length === 0) {\r\n      return section.value;\r\n    }\r\n    if (shouldSetAbsolute) {\r\n      if (delta > 0 || isStart) {\r\n        return options[0];\r\n      }\r\n      return options[options.length - 1];\r\n    }\r\n    const currentOptionIndex = options.indexOf(section.value);\r\n    const newOptionIndex = (currentOptionIndex + options.length + delta) % options.length;\r\n    return options[newOptionIndex];\r\n  };\r\n  if (section.contentType === 'digit' || section.contentType === 'digit-with-letter') {\r\n    return adjustDigitSection();\r\n  }\r\n  return adjustLetterSection();\r\n};\r\nexport const getSectionVisibleValue = (section, target) => {\r\n  let value = section.value || section.placeholder;\r\n  const hasLeadingZeros = target === 'non-input' ? section.hasLeadingZerosInFormat : section.hasLeadingZerosInInput;\r\n  if (target === 'non-input' && section.hasLeadingZerosInInput && !section.hasLeadingZerosInFormat) {\r\n    value = Number(value).toString();\r\n  }\r\n\r\n  // In the input, we add an empty character at the end of each section without leading zeros.\r\n  // This makes sure that `onChange` will always be fired.\r\n  // Otherwise, when your input value equals `1/dd/yyyy` (format `M/DD/YYYY` on DayJs),\r\n  // If you press `1`, on the first section, the new value is also `1/dd/yyyy`,\r\n  // So the browser will not fire the input `onChange`.\r\n  const shouldAddInvisibleSpace = ['input-rtl', 'input-ltr'].includes(target) && section.contentType === 'digit' && !hasLeadingZeros && value.length === 1;\r\n  if (shouldAddInvisibleSpace) {\r\n    value = `${value}\\u200e`;\r\n  }\r\n  if (target === 'input-rtl') {\r\n    value = `\\u2068${value}\\u2069`;\r\n  }\r\n  return value;\r\n};\r\nexport const cleanString = dirtyString => dirtyString.replace(/[\\u2066\\u2067\\u2068\\u2069]/g, '');\r\nexport const addPositionPropertiesToSections = (sections, isRTL) => {\r\n  let position = 0;\r\n  let positionInInput = isRTL ? 1 : 0;\r\n  const newSections = [];\r\n  for (let i = 0; i < sections.length; i += 1) {\r\n    const section = sections[i];\r\n    const renderedValue = getSectionVisibleValue(section, isRTL ? 'input-rtl' : 'input-ltr');\r\n    const sectionStr = `${section.startSeparator}${renderedValue}${section.endSeparator}`;\r\n    const sectionLength = cleanString(sectionStr).length;\r\n    const sectionLengthInInput = sectionStr.length;\r\n\r\n    // The ...InInput values consider the unicode characters but do include them in their indexes\r\n    const cleanedValue = cleanString(renderedValue);\r\n    const startInInput = positionInInput + renderedValue.indexOf(cleanedValue[0]) + section.startSeparator.length;\r\n    const endInInput = startInInput + cleanedValue.length;\r\n    newSections.push(_extends({}, section, {\r\n      start: position,\r\n      end: position + sectionLength,\r\n      startInInput,\r\n      endInInput\r\n    }));\r\n    position += sectionLength;\r\n    // Move position to the end of string associated to the current section\r\n    positionInInput += sectionLengthInInput;\r\n  }\r\n  return newSections;\r\n};\r\nconst getSectionPlaceholder = (utils, timezone, localeText, sectionConfig, currentTokenValue) => {\r\n  switch (sectionConfig.type) {\r\n    case 'year':\r\n      {\r\n        return localeText.fieldYearPlaceholder({\r\n          digitAmount: utils.formatByString(utils.dateWithTimezone(undefined, timezone), currentTokenValue).length\r\n        });\r\n      }\r\n    case 'month':\r\n      {\r\n        return localeText.fieldMonthPlaceholder({\r\n          contentType: sectionConfig.contentType\r\n        });\r\n      }\r\n    case 'day':\r\n      {\r\n        return localeText.fieldDayPlaceholder();\r\n      }\r\n    case 'weekDay':\r\n      {\r\n        return localeText.fieldWeekDayPlaceholder({\r\n          contentType: sectionConfig.contentType\r\n        });\r\n      }\r\n    case 'hours':\r\n      {\r\n        return localeText.fieldHoursPlaceholder();\r\n      }\r\n    case 'minutes':\r\n      {\r\n        return localeText.fieldMinutesPlaceholder();\r\n      }\r\n    case 'seconds':\r\n      {\r\n        return localeText.fieldSecondsPlaceholder();\r\n      }\r\n    case 'meridiem':\r\n      {\r\n        return localeText.fieldMeridiemPlaceholder();\r\n      }\r\n    default:\r\n      {\r\n        return currentTokenValue;\r\n      }\r\n  }\r\n};\r\nexport const changeSectionValueFormat = (utils, valueStr, currentFormat, newFormat) => {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (getDateSectionConfigFromFormatToken(utils, currentFormat).type === 'weekDay') {\r\n      throw new Error(\"changeSectionValueFormat doesn't support week day formats\");\r\n    }\r\n  }\r\n  return utils.formatByString(utils.parse(valueStr, currentFormat), newFormat);\r\n};\r\nconst isFourDigitYearFormat = (utils, timezone, format) => utils.formatByString(utils.dateWithTimezone(undefined, timezone), format).length === 4;\r\nexport const doesSectionFormatHaveLeadingZeros = (utils, timezone, contentType, sectionType, format) => {\r\n  if (contentType !== 'digit') {\r\n    return false;\r\n  }\r\n  const now = utils.dateWithTimezone(undefined, timezone);\r\n  switch (sectionType) {\r\n    // We can't use `changeSectionValueFormat`, because  `utils.parse('1', 'YYYY')` returns `1971` instead of `1`.\r\n    case 'year':\r\n      {\r\n        if (isFourDigitYearFormat(utils, timezone, format)) {\r\n          const formatted0001 = utils.formatByString(utils.setYear(now, 1), format);\r\n          return formatted0001 === '0001';\r\n        }\r\n        const formatted2001 = utils.formatByString(utils.setYear(now, 2001), format);\r\n        return formatted2001 === '01';\r\n      }\r\n    case 'month':\r\n      {\r\n        return utils.formatByString(utils.startOfYear(now), format).length > 1;\r\n      }\r\n    case 'day':\r\n      {\r\n        return utils.formatByString(utils.startOfMonth(now), format).length > 1;\r\n      }\r\n    case 'weekDay':\r\n      {\r\n        return utils.formatByString(utils.startOfWeek(now), format).length > 1;\r\n      }\r\n    case 'hours':\r\n      {\r\n        return utils.formatByString(utils.setHours(now, 1), format).length > 1;\r\n      }\r\n    case 'minutes':\r\n      {\r\n        return utils.formatByString(utils.setMinutes(now, 1), format).length > 1;\r\n      }\r\n    case 'seconds':\r\n      {\r\n        return utils.formatByString(utils.setSeconds(now, 1), format).length > 1;\r\n      }\r\n    default:\r\n      {\r\n        throw new Error('Invalid section type');\r\n      }\r\n  }\r\n};\r\nconst getEscapedPartsFromFormat = (utils, format) => {\r\n  const escapedParts = [];\r\n  const {\r\n    start: startChar,\r\n    end: endChar\r\n  } = utils.escapedCharacters;\r\n  const regExp = new RegExp(`(\\\\${startChar}[^\\\\${endChar}]*\\\\${endChar})+`, 'g');\r\n  let match = null;\r\n  // eslint-disable-next-line no-cond-assign\r\n  while (match = regExp.exec(format)) {\r\n    escapedParts.push({\r\n      start: match.index,\r\n      end: regExp.lastIndex - 1\r\n    });\r\n  }\r\n  return escapedParts;\r\n};\r\nexport const splitFormatIntoSections = (utils, timezone, localeText, format, date, formatDensity, shouldRespectLeadingZeros, isRTL) => {\r\n  let startSeparator = '';\r\n  const sections = [];\r\n  const now = utils.date();\r\n  const commitToken = token => {\r\n    if (token === '') {\r\n      return null;\r\n    }\r\n    const sectionConfig = getDateSectionConfigFromFormatToken(utils, token);\r\n    const hasLeadingZerosInFormat = doesSectionFormatHaveLeadingZeros(utils, timezone, sectionConfig.contentType, sectionConfig.type, token);\r\n    const hasLeadingZerosInInput = shouldRespectLeadingZeros ? hasLeadingZerosInFormat : sectionConfig.contentType === 'digit';\r\n    const isValidDate = date != null && utils.isValid(date);\r\n    let sectionValue = isValidDate ? utils.formatByString(date, token) : '';\r\n    let maxLength = null;\r\n    if (hasLeadingZerosInInput) {\r\n      if (hasLeadingZerosInFormat) {\r\n        maxLength = sectionValue === '' ? utils.formatByString(now, token).length : sectionValue.length;\r\n      } else {\r\n        if (sectionConfig.maxLength == null) {\r\n          throw new Error(`MUI: The token ${token} should have a 'maxDigitNumber' property on it's adapter`);\r\n        }\r\n        maxLength = sectionConfig.maxLength;\r\n        if (isValidDate) {\r\n          sectionValue = cleanLeadingZeros(utils, sectionValue, maxLength);\r\n        }\r\n      }\r\n    }\r\n    sections.push(_extends({}, sectionConfig, {\r\n      format: token,\r\n      maxLength,\r\n      value: sectionValue,\r\n      placeholder: getSectionPlaceholder(utils, timezone, localeText, sectionConfig, token),\r\n      hasLeadingZeros: hasLeadingZerosInFormat,\r\n      hasLeadingZerosInFormat,\r\n      hasLeadingZerosInInput,\r\n      startSeparator: sections.length === 0 ? startSeparator : '',\r\n      endSeparator: '',\r\n      modified: false\r\n    }));\r\n    return null;\r\n  };\r\n\r\n  // Expand the provided format\r\n  let formatExpansionOverflow = 10;\r\n  let prevFormat = format;\r\n  let nextFormat = utils.expandFormat(format);\r\n  while (nextFormat !== prevFormat) {\r\n    prevFormat = nextFormat;\r\n    nextFormat = utils.expandFormat(prevFormat);\r\n    formatExpansionOverflow -= 1;\r\n    if (formatExpansionOverflow < 0) {\r\n      throw new Error('MUI: The format expansion seems to be  enter in an infinite loop. Please open an issue with the format passed to the picker component');\r\n    }\r\n  }\r\n  const expandedFormat = nextFormat;\r\n\r\n  // Get start/end indexes of escaped sections\r\n  const escapedParts = getEscapedPartsFromFormat(utils, expandedFormat);\r\n\r\n  // This RegExp test if the beginning of a string correspond to a supported token\r\n  const isTokenStartRegExp = new RegExp(`^(${Object.keys(utils.formatTokenMap).sort((a, b) => b.length - a.length) // Sort to put longest word first\r\n  .join('|')})`, 'g') // used to get access to lastIndex state\r\n  ;\r\n\r\n  let currentTokenValue = '';\r\n  for (let i = 0; i < expandedFormat.length; i += 1) {\r\n    const escapedPartOfCurrentChar = escapedParts.find(escapeIndex => escapeIndex.start <= i && escapeIndex.end >= i);\r\n    const char = expandedFormat[i];\r\n    const isEscapedChar = escapedPartOfCurrentChar != null;\r\n    const potentialToken = `${currentTokenValue}${expandedFormat.slice(i)}`;\r\n    const regExpMatch = isTokenStartRegExp.test(potentialToken);\r\n    if (!isEscapedChar && char.match(/([A-Za-z]+)/) && regExpMatch) {\r\n      currentTokenValue = potentialToken.slice(0, isTokenStartRegExp.lastIndex);\r\n      i += isTokenStartRegExp.lastIndex - 1;\r\n    } else {\r\n      // If we are on the opening or closing character of an escaped part of the format,\r\n      // Then we ignore this character.\r\n      const isEscapeBoundary = isEscapedChar && (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.start) === i || (escapedPartOfCurrentChar == null ? void 0 : escapedPartOfCurrentChar.end) === i;\r\n      if (!isEscapeBoundary) {\r\n        commitToken(currentTokenValue);\r\n        currentTokenValue = '';\r\n        if (sections.length === 0) {\r\n          startSeparator += char;\r\n        } else {\r\n          sections[sections.length - 1].endSeparator += char;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  commitToken(currentTokenValue);\r\n  return sections.map(section => {\r\n    const cleanSeparator = separator => {\r\n      let cleanedSeparator = separator;\r\n      if (isRTL && cleanedSeparator !== null && cleanedSeparator.includes(' ')) {\r\n        cleanedSeparator = `\\u2069${cleanedSeparator}\\u2066`;\r\n      }\r\n      if (formatDensity === 'spacious' && ['/', '.', '-'].includes(cleanedSeparator)) {\r\n        cleanedSeparator = ` ${cleanedSeparator} `;\r\n      }\r\n      return cleanedSeparator;\r\n    };\r\n    section.startSeparator = cleanSeparator(section.startSeparator);\r\n    section.endSeparator = cleanSeparator(section.endSeparator);\r\n    return section;\r\n  });\r\n};\r\n\r\n/**\r\n * Some date libraries like `dayjs` don't support parsing from date with escaped characters.\r\n * To make sure that the parsing works, we are building a format and a date without any separator.\r\n */\r\nexport const getDateFromDateSections = (utils, sections) => {\r\n  // If we have both a day and a weekDay section,\r\n  // Then we skip the weekDay in the parsing because libraries like dayjs can't parse complicated formats containing a weekDay.\r\n  // dayjs(dayjs().format('dddd MMMM D YYYY'), 'dddd MMMM D YYYY')) // returns `Invalid Date` even if the format is valid.\r\n  const shouldSkipWeekDays = sections.some(section => section.type === 'day');\r\n  const sectionFormats = [];\r\n  const sectionValues = [];\r\n  for (let i = 0; i < sections.length; i += 1) {\r\n    const section = sections[i];\r\n    const shouldSkip = shouldSkipWeekDays && section.type === 'weekDay';\r\n    if (!shouldSkip) {\r\n      sectionFormats.push(section.format);\r\n      sectionValues.push(getSectionVisibleValue(section, 'non-input'));\r\n    }\r\n  }\r\n  const formatWithoutSeparator = sectionFormats.join(' ');\r\n  const dateWithoutSeparatorStr = sectionValues.join(' ');\r\n  return utils.parse(dateWithoutSeparatorStr, formatWithoutSeparator);\r\n};\r\nexport const createDateStrForInputFromSections = (sections, isRTL) => {\r\n  const formattedSections = sections.map(section => {\r\n    const dateValue = getSectionVisibleValue(section, isRTL ? 'input-rtl' : 'input-ltr');\r\n    return `${section.startSeparator}${dateValue}${section.endSeparator}`;\r\n  });\r\n  const dateStr = formattedSections.join('');\r\n  if (!isRTL) {\r\n    return dateStr;\r\n  }\r\n\r\n  // \\u2066: start left-to-right isolation\r\n  // \\u2067: start right-to-left isolation\r\n  // \\u2068: start first strong character isolation\r\n  // \\u2069: pop isolation\r\n  // wrap into an isolated group such that separators can split the string in smaller ones by adding \\u2069\\u2068\r\n  return `\\u2066${dateStr}\\u2069`;\r\n};\r\nexport const getSectionsBoundaries = (utils, timezone) => {\r\n  const today = utils.dateWithTimezone(undefined, timezone);\r\n  const endOfYear = utils.endOfYear(today);\r\n  const endOfDay = utils.endOfDay(today);\r\n  const {\r\n    maxDaysInMonth,\r\n    longestMonth\r\n  } = getMonthsInYear(utils, today).reduce((acc, month) => {\r\n    const daysInMonth = utils.getDaysInMonth(month);\r\n    if (daysInMonth > acc.maxDaysInMonth) {\r\n      return {\r\n        maxDaysInMonth: daysInMonth,\r\n        longestMonth: month\r\n      };\r\n    }\r\n    return acc;\r\n  }, {\r\n    maxDaysInMonth: 0,\r\n    longestMonth: null\r\n  });\r\n  return {\r\n    year: ({\r\n      format\r\n    }) => ({\r\n      minimum: 0,\r\n      maximum: isFourDigitYearFormat(utils, timezone, format) ? 9999 : 99\r\n    }),\r\n    month: () => ({\r\n      minimum: 1,\r\n      // Assumption: All years have the same amount of months\r\n      maximum: utils.getMonth(endOfYear) + 1\r\n    }),\r\n    day: ({\r\n      currentDate\r\n    }) => ({\r\n      minimum: 1,\r\n      maximum: currentDate != null && utils.isValid(currentDate) ? utils.getDaysInMonth(currentDate) : maxDaysInMonth,\r\n      longestMonth: longestMonth\r\n    }),\r\n    weekDay: ({\r\n      format,\r\n      contentType\r\n    }) => {\r\n      if (contentType === 'digit') {\r\n        const daysInWeek = getDaysInWeekStr(utils, timezone, format).map(Number);\r\n        return {\r\n          minimum: Math.min(...daysInWeek),\r\n          maximum: Math.max(...daysInWeek)\r\n        };\r\n      }\r\n      return {\r\n        minimum: 1,\r\n        maximum: 7\r\n      };\r\n    },\r\n    hours: ({\r\n      format\r\n    }) => {\r\n      const lastHourInDay = utils.getHours(endOfDay);\r\n      const hasMeridiem = utils.formatByString(utils.endOfDay(today), format) !== lastHourInDay.toString();\r\n      if (hasMeridiem) {\r\n        return {\r\n          minimum: 1,\r\n          maximum: Number(utils.formatByString(utils.startOfDay(today), format))\r\n        };\r\n      }\r\n      return {\r\n        minimum: 0,\r\n        maximum: lastHourInDay\r\n      };\r\n    },\r\n    minutes: () => ({\r\n      minimum: 0,\r\n      // Assumption: All years have the same amount of minutes\r\n      maximum: utils.getMinutes(endOfDay)\r\n    }),\r\n    seconds: () => ({\r\n      minimum: 0,\r\n      // Assumption: All years have the same amount of seconds\r\n      maximum: utils.getSeconds(endOfDay)\r\n    }),\r\n    meridiem: () => ({\r\n      minimum: 0,\r\n      maximum: 0\r\n    })\r\n  };\r\n};\r\nlet warnedOnceInvalidSection = false;\r\nexport const validateSections = (sections, valueType) => {\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    if (!warnedOnceInvalidSection) {\r\n      const supportedSections = [];\r\n      if (['date', 'date-time'].includes(valueType)) {\r\n        supportedSections.push('weekDay', 'day', 'month', 'year');\r\n      }\r\n      if (['time', 'date-time'].includes(valueType)) {\r\n        supportedSections.push('hours', 'minutes', 'seconds', 'meridiem');\r\n      }\r\n      const invalidSection = sections.find(section => !supportedSections.includes(section.type));\r\n      if (invalidSection) {\r\n        console.warn(`MUI: The field component you are using is not compatible with the \"${invalidSection.type} date section.`, `The supported date sections are [\"${supportedSections.join('\", \"')}\"]\\`.`);\r\n        warnedOnceInvalidSection = true;\r\n      }\r\n    }\r\n  }\r\n};\r\nconst transferDateSectionValue = (utils, timezone, section, dateToTransferFrom, dateToTransferTo) => {\r\n  switch (section.type) {\r\n    case 'year':\r\n      {\r\n        return utils.setYear(dateToTransferTo, utils.getYear(dateToTransferFrom));\r\n      }\r\n    case 'month':\r\n      {\r\n        return utils.setMonth(dateToTransferTo, utils.getMonth(dateToTransferFrom));\r\n      }\r\n    case 'weekDay':\r\n      {\r\n        const formattedDaysInWeek = getDaysInWeekStr(utils, timezone, section.format);\r\n        const dayInWeekStrOfActiveDate = utils.formatByString(dateToTransferFrom, section.format);\r\n        const dayInWeekOfActiveDate = formattedDaysInWeek.indexOf(dayInWeekStrOfActiveDate);\r\n        const dayInWeekOfNewSectionValue = formattedDaysInWeek.indexOf(section.value);\r\n        const diff = dayInWeekOfNewSectionValue - dayInWeekOfActiveDate;\r\n        return utils.addDays(dateToTransferFrom, diff);\r\n      }\r\n    case 'day':\r\n      {\r\n        return utils.setDate(dateToTransferTo, utils.getDate(dateToTransferFrom));\r\n      }\r\n    case 'meridiem':\r\n      {\r\n        const isAM = utils.getHours(dateToTransferFrom) < 12;\r\n        const mergedDateHours = utils.getHours(dateToTransferTo);\r\n        if (isAM && mergedDateHours >= 12) {\r\n          return utils.addHours(dateToTransferTo, -12);\r\n        }\r\n        if (!isAM && mergedDateHours < 12) {\r\n          return utils.addHours(dateToTransferTo, 12);\r\n        }\r\n        return dateToTransferTo;\r\n      }\r\n    case 'hours':\r\n      {\r\n        return utils.setHours(dateToTransferTo, utils.getHours(dateToTransferFrom));\r\n      }\r\n    case 'minutes':\r\n      {\r\n        return utils.setMinutes(dateToTransferTo, utils.getMinutes(dateToTransferFrom));\r\n      }\r\n    case 'seconds':\r\n      {\r\n        return utils.setSeconds(dateToTransferTo, utils.getSeconds(dateToTransferFrom));\r\n      }\r\n    default:\r\n      {\r\n        return dateToTransferTo;\r\n      }\r\n  }\r\n};\r\nconst reliableSectionModificationOrder = {\r\n  year: 1,\r\n  month: 2,\r\n  day: 3,\r\n  weekDay: 4,\r\n  hours: 5,\r\n  minutes: 6,\r\n  seconds: 7,\r\n  meridiem: 8\r\n};\r\nexport const mergeDateIntoReferenceDate = (utils, timezone, dateToTransferFrom, sections, referenceDate, shouldLimitToEditedSections) =>\r\n// cloning sections before sort to avoid mutating it\r\n[...sections].sort((a, b) => reliableSectionModificationOrder[a.type] - reliableSectionModificationOrder[b.type]).reduce((mergedDate, section) => {\r\n  if (!shouldLimitToEditedSections || section.modified) {\r\n    return transferDateSectionValue(utils, timezone, section, dateToTransferFrom, mergedDate);\r\n  }\r\n  return mergedDate;\r\n}, referenceDate);\r\nexport const isAndroid = () => navigator.userAgent.toLowerCase().indexOf('android') > -1;\r\nexport const getSectionOrder = (sections, isRTL) => {\r\n  const neighbors = {};\r\n  if (!isRTL) {\r\n    sections.forEach((_, index) => {\r\n      const leftIndex = index === 0 ? null : index - 1;\r\n      const rightIndex = index === sections.length - 1 ? null : index + 1;\r\n      neighbors[index] = {\r\n        leftIndex,\r\n        rightIndex\r\n      };\r\n    });\r\n    return {\r\n      neighbors,\r\n      startIndex: 0,\r\n      endIndex: sections.length - 1\r\n    };\r\n  }\r\n  const rtl2ltr = {};\r\n  const ltr2rtl = {};\r\n  let groupedSectionsStart = 0;\r\n  let groupedSectionsEnd = 0;\r\n  let RTLIndex = sections.length - 1;\r\n  while (RTLIndex >= 0) {\r\n    groupedSectionsEnd = sections.findIndex(\r\n    // eslint-disable-next-line @typescript-eslint/no-loop-func\r\n    (section, index) => {\r\n      var _section$endSeparator;\r\n      return index >= groupedSectionsStart && ((_section$endSeparator = section.endSeparator) == null ? void 0 : _section$endSeparator.includes(' ')) &&\r\n      // Special case where the spaces were not there in the initial input\r\n      section.endSeparator !== ' / ';\r\n    });\r\n    if (groupedSectionsEnd === -1) {\r\n      groupedSectionsEnd = sections.length - 1;\r\n    }\r\n    for (let i = groupedSectionsEnd; i >= groupedSectionsStart; i -= 1) {\r\n      ltr2rtl[i] = RTLIndex;\r\n      rtl2ltr[RTLIndex] = i;\r\n      RTLIndex -= 1;\r\n    }\r\n    groupedSectionsStart = groupedSectionsEnd + 1;\r\n  }\r\n  sections.forEach((_, index) => {\r\n    const rtlIndex = ltr2rtl[index];\r\n    const leftIndex = rtlIndex === 0 ? null : rtl2ltr[rtlIndex - 1];\r\n    const rightIndex = rtlIndex === sections.length - 1 ? null : rtl2ltr[rtlIndex + 1];\r\n    neighbors[index] = {\r\n      leftIndex,\r\n      rightIndex\r\n    };\r\n  });\r\n  return {\r\n    neighbors,\r\n    startIndex: rtl2ltr[0],\r\n    endIndex: rtl2ltr[sections.length - 1]\r\n  };\r\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}